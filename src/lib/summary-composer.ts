import { OpenAI } from "openai";
import { logger, AppError } from "./logger";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export interface SummaryCompositionRequest {
  content: string;
  type: 'executive' | 'technical' | 'abstract' | 'overview';
  targetLength: 'brief' | 'medium' | 'detailed';
  audience: 'executive' | 'technical' | 'general' | 'academic';
  userId: string;
  requestId: string;
}

export interface SummaryCompositionResponse {
  summary: string;
  keyPoints: string[];
  wordCount: number;
  readingTime: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    cost: number;
  };
}

export class SummaryComposer {
  private readonly MODEL_COSTS = {
    'gpt-4': { input: 0.03, output: 0.06 },
    'gpt-4-turbo': { input: 0.01, output: 0.03 },
    'gpt-3.5-turbo': { input: 0.0015, output: 0.002 },
  };

  async composeSummary(request: SummaryCompositionRequest): Promise<SummaryCompositionResponse> {
    try {
      const prompt = this.buildSummaryPrompt(request);
      
      logger.info('Generating contextual summary', {
        type: request.type,
        targetLength: request.targetLength,
        audience: request.audience,
        contentLength: request.content.length,
      }, request.userId, request.requestId);

      const model = 'gpt-4-turbo';
      const completion = await openai.chat.completions.create({
        model,
        messages: [
          {
            role: 'system',
            content: 'You are a professional content strategist specializing in creating clear, compelling summaries for different audiences and contexts.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.5,
        max_tokens: this.getMaxTokensForLength(request.targetLength),
        response_format: { type: "json_object" }
      });

      const usage = completion.usage;
      if (!usage) {
        throw new AppError('No usage data returned from OpenAI', 500);
      }

      const responseText = completion.choices[0].message.content;
      if (!responseText) {
        throw new AppError('No content generated by OpenAI', 500);
      }

      let parsedResponse;
      try {
        parsedResponse = JSON.parse(responseText);
      } catch (parseError) {
        logger.error('Failed to parse summary response', {
          error: parseError,
          response: responseText,
        }, request.userId, request.requestId);
        throw new AppError('Invalid response format from AI service', 500);
      }

      const cost = this.calculateCost(usage, model);
      const wordCount = parsedResponse.summary.split(/\s+/).length;
      const readingTime = Math.ceil(wordCount / 200); // Average reading speed: 200 words/minute

      const response: SummaryCompositionResponse = {
        summary: parsedResponse.summary,
        keyPoints: parsedResponse.keyPoints || [],
        wordCount,
        readingTime: `${readingTime} minute${readingTime !== 1 ? 's' : ''}`,
        usage: {
          promptTokens: usage.prompt_tokens,
          completionTokens: usage.completion_tokens,
          totalTokens: usage.total_tokens,
          cost,
        },
      };

      logger.info('Summary generated successfully', {
        type: request.type,
        wordCount,
        keyPointsCount: response.keyPoints.length,
        cost,
      }, request.userId, request.requestId);

      return response;

    } catch (error) {
      logger.error('Summary composition failed', {
        error,
        type: request.type,
        targetLength: request.targetLength,
      }, request.userId, request.requestId);

      if (error instanceof AppError) {
        throw error;
      }

      throw new AppError('Failed to generate summary', 500);
    }
  }

  private buildSummaryPrompt(request: SummaryCompositionRequest): string {
    const lengthInstructions = {
      brief: '100-150 words, focusing on the most essential points',
      medium: '200-300 words, providing balanced coverage of key topics',
      detailed: '400-500 words, including comprehensive analysis and context'
    };

    const audienceInstructions = {
      executive: 'Use strategic language, focus on business value, outcomes, and high-level implications',
      technical: 'Use precise technical terminology, focus on implementation details and technical merit',
      general: 'Use clear, accessible language, avoid jargon, focus on practical benefits',
      academic: 'Use formal academic tone, focus on methodology, evidence, and scholarly significance'
    };

    const typeInstructions = {
      executive: 'Create an executive summary highlighting strategic value, key decisions needed, and business impact',
      technical: 'Create a technical summary focusing on implementation approach, architecture, and technical considerations', 
      abstract: 'Create an abstract summarizing purpose, methodology, findings, and conclusions',
      overview: 'Create an overview providing a comprehensive introduction to the topic and its significance'
    };

    return `Create a ${request.type} summary of the following content for a ${request.audience} audience.

TARGET LENGTH: ${lengthInstructions[request.targetLength]}
AUDIENCE GUIDELINES: ${audienceInstructions[request.audience]}
SUMMARY TYPE: ${typeInstructions[request.type]}

CONTENT TO SUMMARIZE:
${request.content}

REQUIREMENTS:
1. Extract and highlight the most important information
2. Maintain logical flow and coherent structure
3. Use appropriate tone and terminology for the target audience
4. Include actionable insights where relevant
5. Ensure accuracy and avoid misrepresenting the original content

OUTPUT FORMAT (JSON):
{
  "summary": "The complete summary text following the specified requirements",
  "keyPoints": ["Key point 1", "Key point 2", "Key point 3", "etc"],
  "primaryTopic": "Main subject or theme",
  "secondaryTopics": ["Supporting topic 1", "Supporting topic 2"],
  "actionableInsights": ["Insight 1", "Insight 2"] // if applicable
}`;
  }

  private getMaxTokensForLength(targetLength: 'brief' | 'medium' | 'detailed'): number {
    const tokenLimits = {
      brief: 250,
      medium: 500,
      detailed: 800
    };
    return tokenLimits[targetLength];
  }

  private calculateCost(usage: any, model: string): number {
    const costs = this.MODEL_COSTS[model as keyof typeof this.MODEL_COSTS];
    if (!costs) return 0;

    const inputCost = (usage.prompt_tokens / 1000) * costs.input;
    const outputCost = (usage.completion_tokens / 1000) * costs.output;
    return inputCost + outputCost;
  }

  async generateExecutiveSummary(
    projectContent: string,
    userId: string,
    requestId: string
  ): Promise<SummaryCompositionResponse> {
    return this.composeSummary({
      content: projectContent,
      type: 'executive',
      targetLength: 'medium',
      audience: 'executive',
      userId,
      requestId,
    });
  }

  async generateTechnicalAbstract(
    projectContent: string,
    userId: string,
    requestId: string
  ): Promise<SummaryCompositionResponse> {
    return this.composeSummary({
      content: projectContent,
      type: 'abstract',
      targetLength: 'detailed',
      audience: 'technical',
      userId,
      requestId,
    });
  }

  async generateProjectOverview(
    projectContent: string,
    targetAudience: 'executive' | 'technical' | 'general' | 'academic',
    userId: string,
    requestId: string
  ): Promise<SummaryCompositionResponse> {
    return this.composeSummary({
      content: projectContent,
      type: 'overview',
      targetLength: 'medium',
      audience: targetAudience,
      userId,
      requestId,
    });
  }
}

export const summaryComposer = new SummaryComposer();